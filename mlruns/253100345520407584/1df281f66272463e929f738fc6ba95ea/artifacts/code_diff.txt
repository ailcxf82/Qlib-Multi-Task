diff --git a/project/docs/ENGINEERING.md b/project/docs/ENGINEERING.md
index 705d0ee..11c1adb 100644
--- a/project/docs/ENGINEERING.md
+++ b/project/docs/ENGINEERING.md
@@ -54,6 +54,106 @@ metric = {
 
 ---
 
+## 综合信号生成逻辑（代码级）
+
+综合信号 `final` 的形成路径是“多模型预测 →（可选）Qlib Ensemble → Stack 残差修正 → IC 动态加权”。关键代码如下：
+
+### 1. 多模型统一管理
+
+`models/ensemble_manager.py` 根据 `pipeline.yaml -> ensemble` 读取模型清单（默认 LGB/MLP），并统一实例化：
+
+```71:136:project/models/ensemble_manager.py
+specs = (self.ensemble_cfg or {}).get("models") or self._default_specs()
+for spec in specs:
+    model = create_model(spec["type"], cfg_path)
+    self.models[name] = model
+```
+
+`predict()` 会逐一调用模型：
+
+```115:127:project/models/ensemble_manager.py
+output = model.predict(feat)
+if isinstance(output, tuple):
+    preds[name], aux[name] = output       # LGB 返回 (Series, leaf_index)
+else:
+    preds[name] = output                  # 其他模型只返回预测
+if self.aggregator:
+    blended = self.aggregator.aggregate(preds)  # Qlib AverageEnsemble
+```
+
+> `preds` 收集了各模型的 `pd.Series` 预测，`aux` 用于携带 LGB 叶子索引供 Stack 使用。
+
+### 2. Stack 残差模型
+
+`models/stack_model.py` 使用 LightGBM 的 `leaf_index` 作为输入（默认经 FeatureHasher 压缩），训练 residual MLP 并融合：
+
+```39:132:project/models/stack_model.py
+train_df = self._hash_leaf(train_leaf, train_residual.index)
+self.mlp.fit(train_df, train_residual, ...)
+...
+residual_pred = self.stack.predict_residual(lgb_leaf, features.index)
+stack_pred = self.stack.fuse(lgb_pred, residual_pred)  # lgb + alpha * residual
+```
+
+Stack 输出作为 `preds["stack"]`，本质是对 LGB 的结构化错误做二级补偿。
+
+### 3. Qlib Ensemble（可选）
+
+若 `ensemble.aggregator` 配置为 `average` 等，`_QlibAverageAdapter` 会先对所有模型预测做标准化再求均值，生成额外的 `qlib_ensemble` 序列：
+
+```16:34:project/models/ensemble_manager.py
+formatted = {name: series.to_frame(name) for ...}
+result = AverageEnsemble()(formatted)
+return result.mean(axis=1).rename("qlib_ensemble")
+```
+
+这一列主要用于观察纯粹的“标准化平均”效果，同时也可以被动态加权模块使用。
+
+### 4. IC 动态加权 → `final`
+
+`predictor/predictor.py` 汇总所有预测后，调用 `RankICDynamicWeighter`：
+
+```45:71:project/predictor/predictor.py
+blend_pred, base_preds, aux = self.ensemble.predict(features)
+preds = dict(base_preds)
+preds["stack"] = stack_pred
+if blend_pred is not None:
+    preds["qlib_ensemble"] = blend_pred
+weights = self.weighter.get_weights(ic_histories)
+final_pred = self.weighter.blend(preds, weights)
+```
+
+`ic_histories` 来自 `data/logs/training_metrics.csv` 的 `ic_lgb/ic_mlp/ic_stack/ic_qlib_ensemble`，`RankICDynamicWeighter` 会计算每条 IC 序列的 IC-IR，并按半衰期、clip/min/max 规则生成权重：
+
+```57:71:project/predictor/weight_dynamic.py
+scores = {name: self._ic_ir(series) for ...}
+scores = {k: max(0, v)} if clip_negative else scores
+weights = normalize_clip(scores, min_weight, max_weight)
+combined = Σ (pred[name] * weights[name])
+```
+
+因此 `final` = `Σ_i weight_i * pred_i`，其中 `pred_i` 包含 LGB、MLP、Stack、qlib_ensemble 等。
+
+### 5. 输出
+
+`save_predictions()` 将 `final` 与各模型列写入 CSV，并统一索引顺序：
+
+```68:75:project/predictor/predictor.py
+df = df.reorder_levels(["datetime", "instrument"]).sort_index()
+df.to_csv(..., index_label=["datetime", "instrument"])
+```
+
+### 6. 优化入口
+
+- 在 `config/pipeline.yaml -> ensemble.models` 增删模型、调整配置。
+- 在 `RankICDynamicWeighter` 中更改半衰期、clip 策略或替换算法。
+- 修改 `LeafStackModel` 的 `encoding/hash_dim` 或 `alpha` 配置，探索不同 residual 方案。
+- 自定义新的 Ensemble 聚合策略，替代默认平均。
+
+通过这些模块，可快速定位综合信号的任何计算阶段并进行优化或排查。
+
+---
+
 ## 回测流程详解
 
 ### 1. 输入数据
diff --git a/project/feature/__pycache__/qlib_feature_pipeline.cpython-311.pyc b/project/feature/__pycache__/qlib_feature_pipeline.cpython-311.pyc
index 073ae9f..09c4d6d 100644
Binary files a/project/feature/__pycache__/qlib_feature_pipeline.cpython-311.pyc and b/project/feature/__pycache__/qlib_feature_pipeline.cpython-311.pyc differ
diff --git a/project/run_backtest.py b/project/run_backtest.py
index 3bcd38c..77d2335 100644
--- a/project/run_backtest.py
+++ b/project/run_backtest.py
@@ -96,6 +96,7 @@ def main():
     )
 
     results = []
+    detail_frames = []
     for dt in sorted(preds.index.get_level_values("datetime").unique()):
         score = preds.xs(dt)
         try:
@@ -111,6 +112,17 @@ def main():
             continue
         ret = (weights.loc[realized.index] * realized).sum()
         results.append({"date": dt, "return": ret})
+        detail = pd.DataFrame(
+            {
+                "date": dt,
+                "instrument": realized.index,
+                "signal": score.reindex(realized.index).values,
+                "weight": weights.reindex(realized.index).values,
+                "label": realized.values,
+            }
+        )
+        detail["contribution"] = detail["weight"] * detail["label"]
+        detail_frames.append(detail)
 
     if not results:
         logging.warning("未生成任何回测记录")
@@ -130,6 +142,11 @@ def main():
     out_path = os.path.join(cfg["paths"]["backtest_dir"], "backtest_result.csv")
     df.to_csv(out_path, index=False)
     logging.info("回测完成，结果写入 %s", out_path)
+    if detail_frames:
+        detail_df = pd.concat(detail_frames, ignore_index=True)
+        detail_path = os.path.join(cfg["paths"]["backtest_dir"], "backtest_detail.csv")
+        detail_df.to_csv(detail_path, index=False)
+        logging.info("投资明细写入 %s", detail_path)
     logging.info("统计指标: %s", stats)
 
 
diff --git a/project/trainer/__pycache__/trainer.cpython-311.pyc b/project/trainer/__pycache__/trainer.cpython-311.pyc
index 095cab1..6eec493 100644
Binary files a/project/trainer/__pycache__/trainer.cpython-311.pyc and b/project/trainer/__pycache__/trainer.cpython-311.pyc differ
diff --git a/project/trainer/trainer.py b/project/trainer/trainer.py
index 2d0c5e9..d3910d3 100644
--- a/project/trainer/trainer.py
+++ b/project/trainer/trainer.py
@@ -105,7 +105,7 @@ class RollingTrainer:
             # 统一训练多模型
             self.ensemble.fit(train_feat, train_lbl, valid_feat, valid_lbl)
 
-            _, train_preds, train_aux = self.ensemble.predict(train_feat)
+            train_blend, train_preds, train_aux = self.ensemble.predict(train_feat)
             lgb_train_pred = train_preds.get("lgb")
             lgb_train_leaf = train_aux.get("lgb")
             if lgb_train_pred is None or lgb_train_leaf is None:
@@ -126,7 +126,19 @@ class RollingTrainer:
             valid_residual = None if (not has_valid or valid_pred is None) else valid_lbl - valid_pred
             self.stack.fit(train_leaf, train_residual, valid_leaf, valid_residual)
 
-            # 计算验证集 IC
+            metric = {
+                "window": idx,
+                "train_start": window.train_start,
+                "train_end": window.train_end,
+                "valid_start": window.valid_start,
+                "valid_end": window.valid_end,
+                "segment": "valid" if has_valid else "train",
+                "ic_lgb": float("nan"),
+                "ic_mlp": float("nan"),
+                "ic_stack": float("nan"),
+                "ic_qlib_ensemble": float("nan"),
+            }
+
             if has_valid:
                 mlp_valid_pred = valid_preds.get("mlp") if valid_preds is not None else None
                 stack_residual = self.stack.predict_residual(valid_leaf, valid_feat.index) if valid_leaf is not None else None
@@ -135,18 +147,26 @@ class RollingTrainer:
                     if (valid_pred is not None and stack_residual is not None)
                     else None
                 )
-                metric = {
-                    "window": idx,
-                    "train_start": window.train_start,
-                    "train_end": window.train_end,
-                    "valid_start": window.valid_start,
-                    "valid_end": window.valid_end,
-                    "ic_lgb": _rank_ic(valid_pred, valid_lbl) if valid_pred is not None else float("nan"),
-                    "ic_mlp": _rank_ic(mlp_valid_pred, valid_lbl) if mlp_valid_pred is not None else float("nan"),
-                    "ic_stack": _rank_ic(stack_valid_pred, valid_lbl) if stack_valid_pred is not None else float("nan"),
-                    "ic_qlib_ensemble": _rank_ic(valid_blend, valid_lbl) if valid_blend is not None else float("nan"),
-                }
-                metrics.append(metric)
+                if valid_pred is not None:
+                    metric["ic_lgb"] = _rank_ic(valid_pred, valid_lbl)
+                if mlp_valid_pred is not None:
+                    metric["ic_mlp"] = _rank_ic(mlp_valid_pred, valid_lbl)
+                if stack_valid_pred is not None:
+                    metric["ic_stack"] = _rank_ic(stack_valid_pred, valid_lbl)
+                if valid_blend is not None:
+                    metric["ic_qlib_ensemble"] = _rank_ic(valid_blend, valid_lbl)
+            else:
+                # 退化为训练集指标，至少保证输出文件存在，便于预测阶段读取
+                mlp_train_pred = train_preds.get("mlp")
+                stack_train_residual = self.stack.predict_residual(train_leaf, train_feat.index)
+                stack_train_pred = self.stack.fuse(lgb_train_pred, stack_train_residual)
+                metric["ic_lgb"] = _rank_ic(lgb_train_pred, train_lbl)
+                if mlp_train_pred is not None:
+                    metric["ic_mlp"] = _rank_ic(mlp_train_pred, train_lbl)
+                metric["ic_stack"] = _rank_ic(stack_train_pred, train_lbl)
+                if train_blend is not None:
+                    metric["ic_qlib_ensemble"] = _rank_ic(train_blend, train_lbl)
+            metrics.append(metric)
 
             # 以验证区间结束日作为模型文件名，方便按日期加载
             tag = window.valid_end.replace("-", "")
